import { supabase } from '../lib/supabase';
import { validateUsername, sanitizeUsername, generateSafeUsername } from '../utils/usernameValidator';

/**
 * User service for managing user data, XP, levels, and display names
 */

/**
 * Convert a guest ID to a valid UUID
 * Uses a deterministic approach to generate a UUID v4-like string from guest ID
 */
function guestIdToUUID(guestId) {
  // If it's already a valid UUID format, return it
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  if (uuidRegex.test(guestId)) {
    return guestId;
  }
  
  // Generate a deterministic UUID from the guest ID string
  // Create a simple hash from the string
  let hash1 = 0;
  let hash2 = 0;
  for (let i = 0; i < guestId.length; i++) {
    const char = guestId.charCodeAt(i);
    hash1 = ((hash1 << 5) - hash1) + char;
    hash1 = hash1 & hash1;
    hash2 = ((hash2 << 3) - hash2) + char;
    hash2 = hash2 & hash2;
  }
  
  // Generate UUID v4 format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
  const h1 = Math.abs(hash1).toString(16).padStart(8, '0');
  const h2 = Math.abs(hash2).toString(16).padStart(8, '0');
  const h3 = Math.abs(hash1 ^ hash2).toString(16).padStart(8, '0');
  const h4 = Math.abs(hash1 + hash2).toString(16).padStart(8, '0');
  
  // Format as UUID: 8-4-4-4-12
  const uuid = `${h1.slice(0, 8)}-${h2.slice(0, 4)}-4${h3.slice(0, 3)}-${(Math.abs(hash1) % 4 + 8).toString(16)}${h4.slice(0, 3)}-${h1.slice(0, 4)}${h2.slice(0, 4)}${h3.slice(0, 4)}`;
  
  return uuid;
}

/**
 * Get or create user from Game Center profile
 * Validates and sanitizes display name
 */
export async function getOrCreateUser(gameCenterProfile) {
  if (!supabase) {
    console.warn('Supabase not configured');
    return null;
  }

  const { playerId, displayName } = gameCenterProfile;

  if (!playerId) {
    console.error('No playerId provided');
    return null;
  }

  // Use playerId as external_id; internal id will be UUID generated by Supabase
  const externalId = playerId;

  try {
    // Don't auto-set display name - always set to null for new users
    // User will set it themselves on the display name setup screen

    // Check if user exists by external_id
    const { data: existingUser, error: fetchError } = await supabase
      .from('users')
      .select('*')
      .eq('external_id', externalId)
      .single();

    if (fetchError && fetchError.code !== 'PGRST116') { // PGRST116 = not found
      console.error('Error fetching user:', fetchError);
      return null;
    }

    if (existingUser) {
      // Update last_seen_at
      const updates = {
        last_seen_at: new Date().toISOString(),
      };

      // Don't auto-update display_name - let user set it themselves
      // Only update last_seen_at
      const { data: updatedUser, error: updateError } = await supabase
        .from('users')
        .update(updates)
        .eq('external_id', externalId)
        .select()
        .single();

      if (updateError) {
        console.error('Error updating user:', updateError);
        return existingUser;
      }

      console.log('[userService] Existing user loaded:', { 
        id: updatedUser?.id || existingUser.id, 
        display_name: updatedUser?.display_name || existingUser.display_name 
      });
      return updatedUser || existingUser;
    }

    // Create new user without display_name - user will set it on first login
    const { data: newUser, error: createError } = await supabase
      .from('users')
      .insert({
        external_id: externalId,
        display_name: null, // User will set this on first login
        xp: 0,
        level: 1,
        coins: 0,
        is_active: true,
        created_at: new Date().toISOString(),
        last_seen_at: new Date().toISOString(),
      })
      .select()
      .single();

    if (createError) {
      console.error('Error creating user:', createError);
      return null;
    }

    console.log('[userService] Created new user without display_name:', newUser?.id);
    return newUser;
  } catch (err) {
    console.error('Error in getOrCreateUser:', err);
    return null;
  }
}

/**
 * Award XP to user after completing a game
 * @param {string} userId - User ID
 * @param {number} xpAmount - Amount of XP to award
 * @returns {Promise<Object>} Updated user object
 */
export async function awardXP(userId, xpAmount) {
  if (!supabase || !userId || !xpAmount) {
    return null;
  }

  try {
    // Get current user
    const { data: user, error: fetchError } = await supabase
      .from('users')
      .select('xp, level')
      .eq('id', userId)
      .single();

    if (fetchError || !user) {
      console.error('Error fetching user for XP:', fetchError);
      return null;
    }

    const newXP = user.xp + xpAmount;
    
    // Calculate new level
    let newLevel = user.level;
    let levelXP = 100 * newLevel * (newLevel + 1) / 2;
    
    while (newXP >= levelXP) {
      newLevel++;
      levelXP = 100 * newLevel * (newLevel + 1) / 2;
    }

    // Update user
    const { data: updatedUser, error: updateError } = await supabase
      .from('users')
      .update({
        xp: newXP,
        level: newLevel,
      })
      .eq('id', userId)
      .select()
      .single();

    if (updateError) {
      console.error('Error updating XP:', updateError);
      return null;
    }

    return updatedUser;
  } catch (err) {
    console.error('Error in awardXP:', err);
    return null;
  }
}

/**
 * Get user by ID
 */
export async function getUser(userId) {
  if (!supabase || !userId) {
    return null;
  }

  try {
    const { data: user, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single();

    if (error) {
      console.error('Error fetching user:', error);
      return null;
    }

    return user;
  } catch (err) {
    console.error('Error in getUser:', err);
    return null;
  }
}

/**
 * Calculate XP reward for completing a game
 * Base XP + bonus for words found + time bonus
 */
export function calculateXPReward(wordsFound, totalWords, timeSeconds = null) {
  const baseXP = 50;
  const wordsXP = (wordsFound / totalWords) * 100; // Up to 100 XP for finding all words
  const timeBonus = timeSeconds ? Math.max(0, 200 - timeSeconds) / 2 : 0; // Up to 100 XP for speed
  
  return Math.round(baseXP + wordsXP + timeBonus);
}

